// -------------------------------------------------------------
// 
// File Name: hdlsrc\gm_hdlcoder_commviterbi\ACS.v
// Created: 2024-06-18 17:16:01
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: ACS
// Source Path: gm_hdlcoder_commviterbi/Viterbi Decoder Subsystem/Viterbi Decoder1/ACS
// Hierarchy Level: 2
// Model version: 10.6
// 
// ACS: connects the add-compare and select units
// and performs the state metric normalization
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module ACS
          (clk,
           reset,
           enb,
           acs_in_0,
           acs_in_1,
           acs_in_2,
           acs_in_3,
           dec_0,
           dec_1,
           dec_2,
           dec_3,
           dec_4,
           dec_5,
           dec_6,
           dec_7,
           idx);


  input   clk;
  input   reset;
  input   enb;
  input   [1:0] acs_in_0;  // ufix2
  input   [1:0] acs_in_1;  // ufix2
  input   [1:0] acs_in_2;  // ufix2
  input   [1:0] acs_in_3;  // ufix2
  output  dec_0;  // ufix1
  output  dec_1;  // ufix1
  output  dec_2;  // ufix1
  output  dec_3;  // ufix1
  output  dec_4;  // ufix1
  output  dec_5;  // ufix1
  output  dec_6;  // ufix1
  output  dec_7;  // ufix1
  output  [2:0] idx;  // ufix3


  wire [1:0] acs_in [0:3];  // ufix2 [4]
  reg [1:0] syncnt;  // ufix2
  wire isCntLimit;  // ufix1
  wire synaccu;  // ufix1
  reg  dsyncaccu;  // ufix1
  wire stMetregEnb;
  reg [4:0] stMet [0:7];  // ufix5 [8]
  wire [4:0] nstMet_0;  // ufix5
  wire [4:0] nstMet_1;  // ufix5
  wire [4:0] nstMet_2;  // ufix5
  wire [4:0] nstMet_3;  // ufix5
  wire [4:0] nstMet_4;  // ufix5
  wire [4:0] nstMet_5;  // ufix5
  wire [4:0] nstMet_6;  // ufix5
  wire [4:0] nstMet_7;  // ufix5
  wire [4:0] nstMet [0:7];  // ufix5 [8]
  reg [4:0] stMetRegister_1 [0:7];  // ufix5 [8]
  wire [4:0] bMet_normed [0:3];  // ufix5 [4]
  wire [4:0] normval;  // ufix5
  reg [4:0] dnormval;  // ufix5
  wire [4:0] BMet_adjustment_adders_1 [0:3];  // ufix5 [4]
  wire acsdec_0;  // ufix1
  wire acsdec_1;  // ufix1
  wire acsdec_2;  // ufix1
  wire acsdec_3;  // ufix1
  wire acsdec_4;  // ufix1
  wire acsdec_5;  // ufix1
  wire acsdec_6;  // ufix1
  wire acsdec_7;  // ufix1
  wire intdelay_out_1;  // ufix1
  reg  [4:0] intdelay_1_reg;  // ufix1 [5]
  wire intdelay_out_2;  // ufix1
  wire intdelay_out_3;  // ufix1
  wire intdelay_out_4;  // ufix1
  wire intdelay_out_5;  // ufix1
  wire intdelay_out_6;  // ufix1
  wire intdelay_out_7;  // ufix1
  wire intdelay_out_8;  // ufix1
  reg  [4:0] intdelay_1_reg_1;  // ufix1 [5]
  reg  [4:0] intdelay_1_reg_2;  // ufix1 [5]
  reg  [4:0] intdelay_1_reg_3;  // ufix1 [5]
  reg  [4:0] intdelay_1_reg_4;  // ufix1 [5]
  reg  [4:0] intdelay_1_reg_5;  // ufix1 [5]
  reg  [4:0] intdelay_1_reg_6;  // ufix1 [5]
  reg  [4:0] intdelay_1_reg_7;  // ufix1 [5]
  reg signed [31:0] stMetRegister_t_0_0;  // int32
  reg signed [31:0] stMetRegister_t_1;  // int32


  assign acs_in[0] = acs_in_0;
  assign acs_in[1] = acs_in_1;
  assign acs_in[2] = acs_in_2;
  assign acs_in[3] = acs_in_3;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 2
  // Delays used to synchronize the state metric with valid branch metric data
  always @(posedge clk or posedge reset)
    begin : counter_process
      if (reset == 1'b1) begin
        syncnt <= 2'b00;
      end
      else begin
        if (enb) begin
          if (syncnt >= 2'b10) begin
            syncnt <= 2'b00;
          end
          else begin
            syncnt <= syncnt + 2'b01;
          end
        end
      end
    end



  assign isCntLimit = syncnt >= 2'b10;



  always @(posedge clk or posedge reset)
    begin : synaccuRegister_process
      if (reset == 1'b1) begin
        dsyncaccu <= 1'b0;
      end
      else begin
        if (enb) begin
          dsyncaccu <= synaccu;
        end
      end
    end



  assign synaccu = isCntLimit | dsyncaccu;



  assign stMetregEnb = synaccu > 1'b0;



  assign nstMet[0] = nstMet_0;
  assign nstMet[1] = nstMet_1;
  assign nstMet[2] = nstMet_2;
  assign nstMet[3] = nstMet_3;
  assign nstMet[4] = nstMet_4;
  assign nstMet[5] = nstMet_5;
  assign nstMet[6] = nstMet_6;
  assign nstMet[7] = nstMet_7;

  // State metric register
  always @(posedge clk or posedge reset)
    begin : stMetRegister_process
      if (reset == 1'b1) begin
        stMetRegister_1[0] <= 5'b00000;
        stMetRegister_1[1] <= 5'b01111;
        stMetRegister_1[2] <= 5'b01111;
        stMetRegister_1[3] <= 5'b01111;
        stMetRegister_1[4] <= 5'b01111;
        stMetRegister_1[5] <= 5'b01111;
        stMetRegister_1[6] <= 5'b01111;
        stMetRegister_1[7] <= 5'b01111;

        for(stMetRegister_t_1 = 32'sd0; stMetRegister_t_1 <= 32'sd7; stMetRegister_t_1 = stMetRegister_t_1 + 32'sd1) begin
          stMet[stMetRegister_t_1] <= stMetRegister_1[stMetRegister_t_1];
        end

      end
      else begin
        if (enb && stMetregEnb) begin
          for(stMetRegister_t_0_0 = 32'sd0; stMetRegister_t_0_0 <= 32'sd7; stMetRegister_t_0_0 = stMetRegister_t_0_0 + 32'sd1) begin
            stMet[stMetRegister_t_0_0] <= nstMet[stMetRegister_t_0_0];
          end
        end
      end
    end



  ACSRenorm u_ACSrenorm_inst (.clk(clk),
                              .reset(reset),
                              .enb(enb),
                              .stMet_0(nstMet_0),  // ufix5
                              .stMet_1(nstMet_1),  // ufix5
                              .stMet_2(nstMet_2),  // ufix5
                              .stMet_3(nstMet_3),  // ufix5
                              .stMet_4(nstMet_4),  // ufix5
                              .stMet_5(nstMet_5),  // ufix5
                              .stMet_6(nstMet_6),  // ufix5
                              .stMet_7(nstMet_7),  // ufix5
                              .normval(normval),  // ufix5
                              .idx(idx)  // ufix3
                              );

  always @(posedge clk or posedge reset)
    begin : NormvalRegister_process
      if (reset == 1'b1) begin
        dnormval <= 5'b00000;
      end
      else begin
        if (enb) begin
          dnormval <= normval;
        end
      end
    end



  // Branch Metric adjustment adders

  genvar t_0_01;
  generate
    for(t_0_01 = 32'sd0; t_0_01 <= 32'sd3; t_0_01 = t_0_01 + 32'sd1) begin:bMet_normed_gen
      assign BMet_adjustment_adders_1[t_0_01] = {3'b0, acs_in[t_0_01]};
      assign bMet_normed[t_0_01] = BMet_adjustment_adders_1[t_0_01] + dnormval;
    end
  endgenerate




  // ACS Unit Instantiation
  // Matching delay from Minimum tree
  ACSEngine u_ACSEngine (.branchMetric_0(bMet_normed[0]),  // ufix5
                         .branchMetric_1(bMet_normed[1]),  // ufix5
                         .branchMetric_2(bMet_normed[2]),  // ufix5
                         .branchMetric_3(bMet_normed[3]),  // ufix5
                         .stateMetric_0(stMet[0]),  // ufix5
                         .stateMetric_1(stMet[1]),  // ufix5
                         .stateMetric_2(stMet[2]),  // ufix5
                         .stateMetric_3(stMet[3]),  // ufix5
                         .stateMetric_4(stMet[4]),  // ufix5
                         .stateMetric_5(stMet[5]),  // ufix5
                         .stateMetric_6(stMet[6]),  // ufix5
                         .stateMetric_7(stMet[7]),  // ufix5
                         .acsDecision_0(acsdec_0),  // ufix1
                         .acsDecision_1(acsdec_1),  // ufix1
                         .acsDecision_2(acsdec_2),  // ufix1
                         .acsDecision_3(acsdec_3),  // ufix1
                         .acsDecision_4(acsdec_4),  // ufix1
                         .acsDecision_5(acsdec_5),  // ufix1
                         .acsDecision_6(acsdec_6),  // ufix1
                         .acsDecision_7(acsdec_7),  // ufix1
                         .nextStateMetric_0(nstMet_0),  // ufix5
                         .nextStateMetric_1(nstMet_1),  // ufix5
                         .nextStateMetric_2(nstMet_2),  // ufix5
                         .nextStateMetric_3(nstMet_3),  // ufix5
                         .nextStateMetric_4(nstMet_4),  // ufix5
                         .nextStateMetric_5(nstMet_5),  // ufix5
                         .nextStateMetric_6(nstMet_6),  // ufix5
                         .nextStateMetric_7(nstMet_7)  // ufix5
                         );

  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        intdelay_1_reg <= {5{1'b0}};
        intdelay_1_reg_1 <= {5{1'b0}};
        intdelay_1_reg_2 <= {5{1'b0}};
        intdelay_1_reg_3 <= {5{1'b0}};
        intdelay_1_reg_4 <= {5{1'b0}};
        intdelay_1_reg_5 <= {5{1'b0}};
        intdelay_1_reg_6 <= {5{1'b0}};
        intdelay_1_reg_7 <= {5{1'b0}};
      end
      else begin
        if (enb) begin
          intdelay_1_reg[0] <= acsdec_0;
          intdelay_1_reg[32'sd4:32'sd1] <= intdelay_1_reg[32'sd3:32'sd0];
          intdelay_1_reg_1[0] <= acsdec_1;
          intdelay_1_reg_1[32'sd4:32'sd1] <= intdelay_1_reg_1[32'sd3:32'sd0];
          intdelay_1_reg_2[0] <= acsdec_2;
          intdelay_1_reg_2[32'sd4:32'sd1] <= intdelay_1_reg_2[32'sd3:32'sd0];
          intdelay_1_reg_3[0] <= acsdec_3;
          intdelay_1_reg_3[32'sd4:32'sd1] <= intdelay_1_reg_3[32'sd3:32'sd0];
          intdelay_1_reg_4[0] <= acsdec_4;
          intdelay_1_reg_4[32'sd4:32'sd1] <= intdelay_1_reg_4[32'sd3:32'sd0];
          intdelay_1_reg_5[0] <= acsdec_5;
          intdelay_1_reg_5[32'sd4:32'sd1] <= intdelay_1_reg_5[32'sd3:32'sd0];
          intdelay_1_reg_6[0] <= acsdec_6;
          intdelay_1_reg_6[32'sd4:32'sd1] <= intdelay_1_reg_6[32'sd3:32'sd0];
          intdelay_1_reg_7[0] <= acsdec_7;
          intdelay_1_reg_7[32'sd4:32'sd1] <= intdelay_1_reg_7[32'sd3:32'sd0];
        end
      end
    end

  assign intdelay_out_1 = intdelay_1_reg[4];
  assign intdelay_out_2 = intdelay_1_reg_1[4];
  assign intdelay_out_3 = intdelay_1_reg_2[4];
  assign intdelay_out_4 = intdelay_1_reg_3[4];
  assign intdelay_out_5 = intdelay_1_reg_4[4];
  assign intdelay_out_6 = intdelay_1_reg_5[4];
  assign intdelay_out_7 = intdelay_1_reg_6[4];
  assign intdelay_out_8 = intdelay_1_reg_7[4];



  assign dec_0 = intdelay_out_1;

  assign dec_1 = intdelay_out_2;

  assign dec_2 = intdelay_out_3;

  assign dec_3 = intdelay_out_4;

  assign dec_4 = intdelay_out_5;

  assign dec_5 = intdelay_out_6;

  assign dec_6 = intdelay_out_7;

  assign dec_7 = intdelay_out_8;

endmodule  // ACS

