// -------------------------------------------------------------
// 
// File Name: hdlsrc\gm_hdlcoder_commviterbi\ACSRenorm.v
// Created: 2024-06-18 17:16:01
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: ACSRenorm
// Source Path: gm_hdlcoder_commviterbi/Viterbi Decoder Subsystem/Viterbi Decoder1/ACS/ACSRenorm
// Hierarchy Level: 3
// Model version: 10.6
// 
// Calculates the minimum state metric value
// Compares the minimum value to the threshold parameter
// If the minimum value is greater than or equal to the threshold value, 
// returns the step parameter; otherwise returns zero
// 
// State Metric Renormalization
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module ACSRenorm
          (clk,
           reset,
           enb,
           stMet_0,
           stMet_1,
           stMet_2,
           stMet_3,
           stMet_4,
           stMet_5,
           stMet_6,
           stMet_7,
           normval,
           idx);


  input   clk;
  input   reset;
  input   enb;
  input   [4:0] stMet_0;  // ufix5
  input   [4:0] stMet_1;  // ufix5
  input   [4:0] stMet_2;  // ufix5
  input   [4:0] stMet_3;  // ufix5
  input   [4:0] stMet_4;  // ufix5
  input   [4:0] stMet_5;  // ufix5
  input   [4:0] stMet_6;  // ufix5
  input   [4:0] stMet_7;  // ufix5
  output  [4:0] normval;  // ufix5
  output  [2:0] idx;  // ufix3


  wire [4:0] stMet [0:7];  // ufix5 [8]
  reg [4:0] stMetRegister_1 [0:7];  // ufix5 [8]
  reg [4:0] dstMet [0:7];  // ufix5 [8]
  wire [4:0] stMet_reorder [0:7];  // ufix5 [8]
  reg [4:0] MininputRegister_1 [0:7];  // ufix5 [8]
  reg [4:0] dstMet_reorder [0:7];  // ufix5 [8]
  wire [2:0] const_idx [0:7];  // ufix3 [8]
  wire [3:0] MinimumTree_treestage1_isless;  // boolean [4]
  wire [4:0] MinimumTree_stage1_val [0:3];  // ufix5 [4]
  wire [2:0] MinimumTree_stage1_idx [0:3];  // ufix3 [4]
  reg [4:0] MinimumTree_stage1_val_reg [0:3];  // ufix5 [4]
  reg [2:0] MinimumTree_stage1_idx_reg [0:3];  // ufix3 [4]
  wire [1:0] MinimumTree_treestage2_isless;  // boolean [2]
  wire [4:0] MinimumTree_stage2_val [0:1];  // ufix5 [2]
  wire [2:0] MinimumTree_stage2_idx [0:1];  // ufix3 [2]
  reg [4:0] MinimumTree_stage2_val_reg [0:1];  // ufix5 [2]
  reg [2:0] MinimumTree_stage2_idx_reg [0:1];  // ufix3 [2]
  wire MinimumTree_treestage3_isless;
  wire [4:0] MinimumTree_stage3_val;  // ufix5
  wire [2:0] MinimumTree_stage3_idx;  // ufix3
  reg [4:0] MinimumTree_stage3_val_reg;  // ufix5
  wire sel;  // ufix1
  wire switch_compare_1;
  wire [4:0] conststep;  // ufix5
  wire [4:0] constzero;  // ufix5
  wire [2:0] idxmax;  // ufix3
  reg [2:0] MinimumTree_stage3_idx_reg;  // ufix3
  reg signed [31:0] stMetRegister_t_0_0;  // int32
  reg signed [31:0] stMetRegister_t_1;  // int32
  reg signed [31:0] MininputRegister_t_0_0;  // int32
  reg signed [31:0] MininputRegister_t_1;  // int32
  reg signed [31:0] MinimumTree_stage1_val_t_0_0;  // int32
  reg signed [31:0] MinimumTree_stage1_val_t_1;  // int32
  reg signed [31:0] MinimumTree_stage1_idx_t_0_0;  // int32
  reg signed [31:0] MinimumTree_stage1_idx_t_1;  // int32
  reg signed [31:0] MinimumTree_stage2_val_t_0_0;  // int32
  reg signed [31:0] MinimumTree_stage2_val_t_1;  // int32
  reg signed [31:0] MinimumTree_stage2_idx_t_0_0;  // int32
  reg signed [31:0] MinimumTree_stage2_idx_t_1;  // int32


  assign stMet[0] = stMet_0;
  assign stMet[1] = stMet_1;
  assign stMet[2] = stMet_2;
  assign stMet[3] = stMet_3;
  assign stMet[4] = stMet_4;
  assign stMet[5] = stMet_5;
  assign stMet[6] = stMet_6;
  assign stMet[7] = stMet_7;

  // Add input register for state metric
  always @(posedge clk or posedge reset)
    begin : stMetRegister_process
      if (reset == 1'b1) begin
        stMetRegister_1[0] <= 5'b01111;
        stMetRegister_1[1] <= 5'b01111;
        stMetRegister_1[2] <= 5'b01111;
        stMetRegister_1[3] <= 5'b01111;
        stMetRegister_1[4] <= 5'b01111;
        stMetRegister_1[5] <= 5'b01111;
        stMetRegister_1[6] <= 5'b01111;
        stMetRegister_1[7] <= 5'b00000;

        for(stMetRegister_t_1 = 32'sd0; stMetRegister_t_1 <= 32'sd7; stMetRegister_t_1 = stMetRegister_t_1 + 32'sd1) begin
          dstMet[stMetRegister_t_1] <= stMetRegister_1[stMetRegister_t_1];
        end

      end
      else begin
        if (enb) begin
          for(stMetRegister_t_0_0 = 32'sd0; stMetRegister_t_0_0 <= 32'sd7; stMetRegister_t_0_0 = stMetRegister_t_0_0 + 32'sd1) begin
            dstMet[stMetRegister_t_0_0] <= stMet[stMetRegister_t_0_0];
          end
        end
      end
    end



  // Reorder state metric to match the minimum idx search
  assign stMet_reorder[0] = dstMet[7];
  assign stMet_reorder[1] = dstMet[6];
  assign stMet_reorder[2] = dstMet[5];
  assign stMet_reorder[3] = dstMet[4];
  assign stMet_reorder[4] = dstMet[3];
  assign stMet_reorder[5] = dstMet[2];
  assign stMet_reorder[6] = dstMet[1];
  assign stMet_reorder[7] = dstMet[0];

  always @(posedge clk or posedge reset)
    begin : MininputRegister_process
      if (reset == 1'b1) begin
        MininputRegister_1[0] <= 5'b01111;
        MininputRegister_1[1] <= 5'b01111;
        MininputRegister_1[2] <= 5'b01111;
        MininputRegister_1[3] <= 5'b01111;
        MininputRegister_1[4] <= 5'b01111;
        MininputRegister_1[5] <= 5'b01111;
        MininputRegister_1[6] <= 5'b01111;
        MininputRegister_1[7] <= 5'b00000;

        for(MininputRegister_t_1 = 32'sd0; MininputRegister_t_1 <= 32'sd7; MininputRegister_t_1 = MininputRegister_t_1 + 32'sd1) begin
          dstMet_reorder[MininputRegister_t_1] <= MininputRegister_1[MininputRegister_t_1];
        end

      end
      else begin
        if (enb) begin
          for(MininputRegister_t_0_0 = 32'sd0; MininputRegister_t_0_0 <= 32'sd7; MininputRegister_t_0_0 = MininputRegister_t_0_0 + 32'sd1) begin
            dstMet_reorder[MininputRegister_t_0_0] <= stMet_reorder[MininputRegister_t_0_0];
          end
        end
      end
    end



  assign const_idx[0] = 3'b000;
  assign const_idx[1] = 3'b001;
  assign const_idx[2] = 3'b010;
  assign const_idx[3] = 3'b011;
  assign const_idx[4] = 3'b100;
  assign const_idx[5] = 3'b101;
  assign const_idx[6] = 3'b110;
  assign const_idx[7] = 3'b111;



  // ---- Tree min implementation ----
  // ---- Tree min stage 1 ----
  assign MinimumTree_treestage1_isless[0] = (dstMet_reorder[0] <= dstMet_reorder[1] ? 1'b1 :
              1'b0);
  assign MinimumTree_stage1_val[0] = (MinimumTree_treestage1_isless[0] ? dstMet_reorder[0] :
              dstMet_reorder[1]);
  assign MinimumTree_stage1_idx[0] = (MinimumTree_treestage1_isless[0] ? const_idx[0] :
              const_idx[1]);
  assign MinimumTree_treestage1_isless[1] = (dstMet_reorder[2] <= dstMet_reorder[3] ? 1'b1 :
              1'b0);
  assign MinimumTree_stage1_val[1] = (MinimumTree_treestage1_isless[1] ? dstMet_reorder[2] :
              dstMet_reorder[3]);
  assign MinimumTree_stage1_idx[1] = (MinimumTree_treestage1_isless[1] ? const_idx[2] :
              const_idx[3]);
  assign MinimumTree_treestage1_isless[2] = (dstMet_reorder[4] <= dstMet_reorder[5] ? 1'b1 :
              1'b0);
  assign MinimumTree_stage1_val[2] = (MinimumTree_treestage1_isless[2] ? dstMet_reorder[4] :
              dstMet_reorder[5]);
  assign MinimumTree_stage1_idx[2] = (MinimumTree_treestage1_isless[2] ? const_idx[4] :
              const_idx[5]);
  assign MinimumTree_treestage1_isless[3] = (dstMet_reorder[6] <= dstMet_reorder[7] ? 1'b1 :
              1'b0);
  assign MinimumTree_stage1_val[3] = (MinimumTree_treestage1_isless[3] ? dstMet_reorder[6] :
              dstMet_reorder[7]);
  assign MinimumTree_stage1_idx[3] = (MinimumTree_treestage1_isless[3] ? const_idx[6] :
              const_idx[7]);



  always @(posedge clk or posedge reset)
    begin : MinimumTree_stage1_val_1_process
      if (reset == 1'b1) begin
        for(MinimumTree_stage1_val_t_1 = 32'sd0; MinimumTree_stage1_val_t_1 <= 32'sd3; MinimumTree_stage1_val_t_1 = MinimumTree_stage1_val_t_1 + 32'sd1) begin
          MinimumTree_stage1_val_reg[MinimumTree_stage1_val_t_1] <= 5'b00000;
        end
      end
      else begin
        if (enb) begin
          for(MinimumTree_stage1_val_t_0_0 = 32'sd0; MinimumTree_stage1_val_t_0_0 <= 32'sd3; MinimumTree_stage1_val_t_0_0 = MinimumTree_stage1_val_t_0_0 + 32'sd1) begin
            MinimumTree_stage1_val_reg[MinimumTree_stage1_val_t_0_0] <= MinimumTree_stage1_val[MinimumTree_stage1_val_t_0_0];
          end
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : MinimumTree_stage1_idx_1_process
      if (reset == 1'b1) begin
        for(MinimumTree_stage1_idx_t_1 = 32'sd0; MinimumTree_stage1_idx_t_1 <= 32'sd3; MinimumTree_stage1_idx_t_1 = MinimumTree_stage1_idx_t_1 + 32'sd1) begin
          MinimumTree_stage1_idx_reg[MinimumTree_stage1_idx_t_1] <= 3'b000;
        end
      end
      else begin
        if (enb) begin
          for(MinimumTree_stage1_idx_t_0_0 = 32'sd0; MinimumTree_stage1_idx_t_0_0 <= 32'sd3; MinimumTree_stage1_idx_t_0_0 = MinimumTree_stage1_idx_t_0_0 + 32'sd1) begin
            MinimumTree_stage1_idx_reg[MinimumTree_stage1_idx_t_0_0] <= MinimumTree_stage1_idx[MinimumTree_stage1_idx_t_0_0];
          end
        end
      end
    end



  // ---- Tree min stage 2 ----
  assign MinimumTree_treestage2_isless[0] = (MinimumTree_stage1_val_reg[0] <= MinimumTree_stage1_val_reg[1] ? 1'b1 :
              1'b0);
  assign MinimumTree_stage2_val[0] = (MinimumTree_treestage2_isless[0] ? MinimumTree_stage1_val_reg[0] :
              MinimumTree_stage1_val_reg[1]);
  assign MinimumTree_stage2_idx[0] = (MinimumTree_treestage2_isless[0] ? MinimumTree_stage1_idx_reg[0] :
              MinimumTree_stage1_idx_reg[1]);
  assign MinimumTree_treestage2_isless[1] = (MinimumTree_stage1_val_reg[2] <= MinimumTree_stage1_val_reg[3] ? 1'b1 :
              1'b0);
  assign MinimumTree_stage2_val[1] = (MinimumTree_treestage2_isless[1] ? MinimumTree_stage1_val_reg[2] :
              MinimumTree_stage1_val_reg[3]);
  assign MinimumTree_stage2_idx[1] = (MinimumTree_treestage2_isless[1] ? MinimumTree_stage1_idx_reg[2] :
              MinimumTree_stage1_idx_reg[3]);



  always @(posedge clk or posedge reset)
    begin : MinimumTree_stage2_val_1_process
      if (reset == 1'b1) begin
        for(MinimumTree_stage2_val_t_1 = 32'sd0; MinimumTree_stage2_val_t_1 <= 32'sd1; MinimumTree_stage2_val_t_1 = MinimumTree_stage2_val_t_1 + 32'sd1) begin
          MinimumTree_stage2_val_reg[MinimumTree_stage2_val_t_1] <= 5'b00000;
        end
      end
      else begin
        if (enb) begin
          for(MinimumTree_stage2_val_t_0_0 = 32'sd0; MinimumTree_stage2_val_t_0_0 <= 32'sd1; MinimumTree_stage2_val_t_0_0 = MinimumTree_stage2_val_t_0_0 + 32'sd1) begin
            MinimumTree_stage2_val_reg[MinimumTree_stage2_val_t_0_0] <= MinimumTree_stage2_val[MinimumTree_stage2_val_t_0_0];
          end
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : MinimumTree_stage2_idx_1_process
      if (reset == 1'b1) begin
        for(MinimumTree_stage2_idx_t_1 = 32'sd0; MinimumTree_stage2_idx_t_1 <= 32'sd1; MinimumTree_stage2_idx_t_1 = MinimumTree_stage2_idx_t_1 + 32'sd1) begin
          MinimumTree_stage2_idx_reg[MinimumTree_stage2_idx_t_1] <= 3'b000;
        end
      end
      else begin
        if (enb) begin
          for(MinimumTree_stage2_idx_t_0_0 = 32'sd0; MinimumTree_stage2_idx_t_0_0 <= 32'sd1; MinimumTree_stage2_idx_t_0_0 = MinimumTree_stage2_idx_t_0_0 + 32'sd1) begin
            MinimumTree_stage2_idx_reg[MinimumTree_stage2_idx_t_0_0] <= MinimumTree_stage2_idx[MinimumTree_stage2_idx_t_0_0];
          end
        end
      end
    end



  // ---- Tree min stage 3 ----
  assign MinimumTree_treestage3_isless = MinimumTree_stage2_val_reg[0] <= MinimumTree_stage2_val_reg[1];
  assign MinimumTree_stage3_val = (MinimumTree_treestage3_isless ? MinimumTree_stage2_val_reg[0] :
              MinimumTree_stage2_val_reg[1]);
  assign MinimumTree_stage3_idx = (MinimumTree_treestage3_isless ? MinimumTree_stage2_idx_reg[0] :
              MinimumTree_stage2_idx_reg[1]);



  always @(posedge clk or posedge reset)
    begin : MinimumTree_stage3_val_1_process
      if (reset == 1'b1) begin
        MinimumTree_stage3_val_reg <= 5'b00000;
      end
      else begin
        if (enb) begin
          MinimumTree_stage3_val_reg <= MinimumTree_stage3_val;
        end
      end
    end



  assign sel = MinimumTree_stage3_val_reg < 5'b00110;



  assign switch_compare_1 = sel > 1'b0;



  // Normalization constant adjustment value
  assign conststep = 5'b11111;



  // Normalization constant zero
  assign constzero = 5'b00000;



  assign normval = (switch_compare_1 == 1'b0 ? conststep :
              constzero);



  // Max value of state index
  assign idxmax = 3'b111;



  always @(posedge clk or posedge reset)
    begin : MinimumTree_stage3_idx_1_process
      if (reset == 1'b1) begin
        MinimumTree_stage3_idx_reg <= 3'b000;
      end
      else begin
        if (enb) begin
          MinimumTree_stage3_idx_reg <= MinimumTree_stage3_idx;
        end
      end
    end



  assign idx = idxmax - MinimumTree_stage3_idx_reg;



endmodule  // ACSRenorm

